import 'mocha-steps';
/* global step: false */

import {
  webrtcHelpers,
  WebRTCMediaEngine
} from '@ciscospark/media-engine-webrtc';
const {
  getMediaDirectionFromSDP,
  reverseMediaDirection
} = webrtcHelpers;
import {assert} from '@ciscospark/test-helper-chai';
import {browserOnly, expectEvent} from '@ciscospark/test-helper-mocha';
import sinon from '@ciscospark/test-helper-sinon';
import {mockAnswer, mockRenegotiate} from '../lib/offer-answer';

function getExpectedMediaDirection(next, previous) {
  if (previous.includes(`recv`)) {
    if (next === `inactive`) {
      return `recvonly`;
    }
    if (next === `sendonly`) {
      return `sendrecv`;
    }
  }

  return next;
}

const backoffPattern = [0, 100, 200, 400, 800];

function retry(fn) {
  return backoffPattern.reduce((promise, delay) => {
    return promise.catch(() => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            resolve(fn());
          }
          catch (err) {
            reject(err);
          }
        }, delay);
      });
    });
  }, Promise.reject());
}

browserOnly(describe)(`media-engine-webrtc`, function() {
  this.timeout(60000);
  describe(`WebRTCMediaEngine`, () => {
    describe(`renegotiation`, () => {
      const audioStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const audioEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      audioStartStates.forEach((audioStart) => {
        audioEndStates.forEach((audioEnd) => {
          videoStartStates.forEach((videoStart) => {
            // all the complexity comes from building the `describe()` block
            // message
            // eslint-disable-next-line complexity
            videoEndStates.forEach((videoEnd) => {
              if (audioStart === `inactive` && videoStart === `inactive`) {
                // not a valid initial state
                return;
              }

              if (audioEnd === `inactive` && videoEnd === `inactive`) {
                return;
              }

              if (audioStart === audioEnd && videoStart === videoEnd) {
                // no changes, therefore nothing to test
                return;
              }

              let expectNewRemoteTrackOnTransition = false;
              expectNewRemoteTrackOnTransition = expectNewRemoteTrackOnTransition || audioStart.includes(`recv`) !== audioEnd.includes(`recv`) && (audioEnd.includes(`recv`));
              expectNewRemoteTrackOnTransition = expectNewRemoteTrackOnTransition || videoStart.includes(`recv`) !== videoEnd.includes(`recv`) && (videoEnd.includes(`recv`));
              let expectToRenegotiateOnTransition = expectNewRemoteTrackOnTransition;
              expectToRenegotiateOnTransition = expectToRenegotiateOnTransition || audioStart.includes(`send`) !== audioEnd.includes(`send`) && (audioStart.includes(`send`) || audioEnd.includes(`send`));
              expectToRenegotiateOnTransition = expectToRenegotiateOnTransition || videoStart.includes(`send`) !== videoEnd.includes(`send`) && (videoStart.includes(`send`) || videoEnd.includes(`send`));

              let sendingAudioChange = false;
              sendingAudioChange = audioStart.includes(`send`) !== audioEnd.includes(`send`);

              let sendingVideoChange = false;
              sendingVideoChange = videoStart.includes(`send`) !== videoEnd.includes(`send`);

              let receivingAudioChange = false;
              receivingAudioChange = audioStart.includes(`recv`) !== audioEnd.includes(`recv`);

              let receivingVideoChange = false;
              receivingVideoChange = videoStart.includes(`recv`) !== videoEnd.includes(`recv`);

              const expectNewRemoteTrackOnReturn = false;
              let expectToRenegotiateOnReturn = expectNewRemoteTrackOnReturn;
              expectToRenegotiateOnReturn = expectToRenegotiateOnReturn || audioStart.includes(`send`) !== audioEnd.includes(`send`) && (audioStart.includes(`send`) || audioEnd.includes(`send`));
              expectToRenegotiateOnReturn = expectToRenegotiateOnReturn || videoStart.includes(`send`) !== videoEnd.includes(`send`) && (videoStart.includes(`send`) || videoEnd.includes(`send`));

              console.log(`AAAAAAAA`, expectToRenegotiateOnReturn, expectNewRemoteTrackOnReturn, audioStart.includes(`send`), audioEnd.includes(`send`), videoStart.includes(`send`), videoEnd.includes(`send`));
              console.log(`BBBBBBBB`, audioStart.includes(`send`), audioEnd.includes(`send`), videoStart.includes(`send`), videoEnd.includes(`send`));

              const message = `when ${[
                audioStart === audioEnd ? `audio is '${audioStart}'` : `audio changes from '${audioStart}' to '${audioEnd}'`,
                videoStart === videoEnd ? `video is '${videoStart}'` : `video changes from '${videoStart}' to '${videoEnd}'`
              ]
                .filter((m) => m)
                .join(` and `)}`;

              describe(message, () => {
                // Note: This describe block is stateful; `step()` statements must
                // execute in order.
                let engine;
                before(() => {
                  engine = new WebRTCMediaEngine();
                  engine.on(`change:receivingVideo`, (value, previous) => console.log(`XXXXX receivingVideo`, engine.receivingVideo, value, previous));
                });

                after(() => {
                  engine.stop();
                });

                step(`initiates a session with audio=${audioStart} and video=${videoStart}`, () => {
                  engine.setMedia(`audio`, audioStart);
                  engine.setMedia(`video`, videoStart);

                  assert.lengthOf(engine.localMediaStream.getTracks(), 0);
                  assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

                  return engine.createOffer()
                    .then((offer) => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

                      assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      return offer;
                    })
                    .then(mockAnswer)
                    .then((answer) => {
                      assertLocalMedia(engine, audioStart, videoStart);

                      assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);
                      assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));
                      assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (audioStart.includes(`recv`) || videoStart.includes(`recv`)) && expectEvent(20000, `track`, engine),
                      engine.acceptAnswer(answer)
                    ]))
                    .then(() => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assertRemoteMedia(engine, audioStart, videoStart);

                      assert.equal(engine.audioDirection, audioStart);
                      assert.equal(engine.videoDirection, videoStart);
                    });
                });

                step(`transitions to audio=${audioEnd} and video=${videoEnd}`, () => {
                  const sendingAudioSpy = sinon.spy();
                  const sendingVideoSpy = sinon.spy();
                  const receivingAudioSpy = sinon.spy();
                  const receivingVideoSpy = sinon.spy();

                  engine.once(`change:sendingAudio`, sendingAudioSpy);
                  engine.once(`change:sendingVideo`, sendingVideoSpy);
                  engine.once(`change:receivingAudio`, receivingAudioSpy);
                  engine.once(`change:receivingVideo`, receivingVideoSpy);

                  const negotiationneededSpy = sinon.spy();
                  const trackSpy = sinon.spy();

                  engine.once(`negotiationneeded`, negotiationneededSpy);
                  engine.once(`track`, trackSpy);

                  engine.setMedia(`audio`, audioEnd);
                  engine.setMedia(`video`, videoEnd);

                  return Promise.all([
                    expectToRenegotiateOnTransition && expectEvent(20000, `negotiationneeded`, engine)
                      .then(() => retry(() => assertLocalMedia(engine, audioEnd, videoEnd)))
                      .then(() => engine.createOffer())
                      .then((offer) => {
                        console.log(engine.pc.getReceivers().length);

                        assertOffer(`audio`, audioEnd, audioStart, offer);
                        assertOffer(`video`, videoEnd, videoStart, offer);

                        return offer;
                      })
                      .then(mockRenegotiate)
                      .then((answer) => {
                        console.log(`receivers before answer`, engine.pc.getReceivers().length);

                        assertAnswer(`audio`, audioEnd, audioStart, answer);
                        assertAnswer(`video`, videoEnd, videoStart, answer);

                        return answer;
                      })
                      .then((answer) => engine.acceptAnswer(answer)),
                    expectNewRemoteTrackOnTransition && expectEvent(20000, `track`, engine)
                  ])
                    .then(() => {
                      console.log(`receivers after answer`, engine.pc.getReceivers().length);

                      assertLocalMedia(engine, audioEnd, videoEnd);
                      assertRemoteMedia(engine, audioEnd, videoEnd);
                      assert.equal(engine.audioDirection, audioEnd);
                      assert.equal(engine.videoDirection, videoEnd);
                    })
                    .then(() => {
                      assertSpyCalledOrNot(expectToRenegotiateOnTransition, negotiationneededSpy);
                      assertSpyCalledOrNot(expectNewRemoteTrackOnTransition, trackSpy);

                      assertSpyCalledOrNot(sendingAudioChange, sendingAudioSpy);
                      assertSpyCalledOrNot(sendingVideoChange, sendingVideoSpy);
                      assertSpyCalledOrNot(receivingAudioChange, receivingAudioSpy);
                      assertSpyCalledOrNot(receivingVideoChange, receivingVideoSpy);
                    });
                });

                step(`returns to audio=${audioStart} and video=${videoStart}`, () => {
                  const sendingAudioSpy = sinon.spy();
                  const sendingVideoSpy = sinon.spy();
                  const receivingAudioSpy = sinon.spy();
                  const receivingVideoSpy = sinon.spy();

                  engine.once(`change:sendingAudio`, sendingAudioSpy);
                  engine.once(`change:sendingVideo`, sendingVideoSpy);
                  engine.once(`change:receivingAudio`, receivingAudioSpy);
                  engine.once(`change:receivingVideo`, receivingVideoSpy);

                  const negotiationneededSpy = sinon.spy();
                  const trackSpy = sinon.spy();

                  engine.once(`negotiationneeded`, negotiationneededSpy);
                  engine.once(`track`, trackSpy);

                  engine.setMedia(`audio`, audioStart);
                  engine.setMedia(`video`, videoStart);

                  return Promise.resolve(expectToRenegotiateOnReturn && expectEvent(20000, `negotiationneeded`, engine)
                    .then(() => engine.createOffer())
                    .then((offer) => {
                      assertOffer(`audio`, audioStart, audioEnd, offer);
                      assertOffer(`video`, videoStart, videoEnd, offer);

                      return offer;
                    })
                    .then(mockRenegotiate)
                    .then((answer) => {
                      assertAnswer(`audio`, audioStart, audioEnd, answer);
                      assertAnswer(`video`, videoStart, videoEnd, answer);

                      return answer;
                    })
                    .then((answer) => Promise.all([
                      expectNewRemoteTrackOnReturn && expectEvent(20000, `track`, engine),
                      engine.acceptAnswer(answer)
                    ])))
                    .then(() => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assertRemoteMedia(engine, audioStart, videoStart);
                      // console.log(engine.pc.getLocalStreams()[0] && engine.pc.getLocalStreams()[0]().map((t) => t.enabled));
                      // console.log(engine.pc.getSenders().filter((s) => s.track.kind === `audio`).map((s) => s.track.enabled));
                      // console.log(engine.localMediaStream.getAudioTracks().map((t) => t.enabled));

                      // console.log(engine.pc.getRemoteStreams()[0] && engine.pc.getRemoteStreams()[0].getAudioTracks().map((t) => t.enabled));
                      // console.log(engine.pc.getReceivers().filter((s) => s.track.kind === `audio`).map((s) => s.track.enabled));
                      // console.log(engine.remoteMediaStream.getAudioTracks().map((t) => t.enabled));

                      assert.equal(engine.audioDirection, audioStart, `expected "audio" to return to "${audioStart}"`);
                      assert.equal(engine.videoDirection, videoStart, `expected "video" to return to "${videoStart}"`);
                    })
                    .then(() => {
                      assertSpyCalledOrNot(expectToRenegotiateOnReturn, negotiationneededSpy);
                      assertSpyCalledOrNot(expectNewRemoteTrackOnReturn, trackSpy);

                      assertSpyCalledOrNot(sendingAudioChange, sendingAudioSpy);
                      assertSpyCalledOrNot(sendingVideoChange, sendingVideoSpy);
                      assertSpyCalledOrNot(receivingAudioChange, receivingAudioSpy);
                      assertSpyCalledOrNot(receivingVideoChange, receivingVideoSpy);
                    });
                });
              });
            });
          });
        });
      });
    });

    [
      `audio`,
      `video`
    ]
      .forEach((kind) => {
        describe(`#(un)pauseSendingMedia(${kind})`, () => {
          it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
            const engine = new WebRTCMediaEngine();
            engine.setMedia(`audio`, `sendrecv`);
            engine.setMedia(`video`, `sendrecv`);
            const spy = sinon.spy();

            return engine.createOffer()
              .then(mockAnswer)
              .then((answer) => Promise.all([
                expectEvent(20000, `track`, engine),
                engine.acceptAnswer(answer)
              ]))
              .then(() => {
                assertLocalMedia(engine, `sendrecv`, `sendrecv`);
                assertRemoteMedia(engine, `sendrecv`, `sendrecv`);

                engine.on(`negotiationneeded`, spy);
                engine.pauseSendingMedia(kind);
                assert.isFalse(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
                assert.isFalse(engine.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
                return new Promise((resolve) => setTimeout(resolve, 500));
              })
              .then(() => assert.notCalled(spy))
              .then(() => {
                assertLocalMedia(engine, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);
                assertRemoteMedia(engine, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);

                engine.on(`negotiationneeded`, spy);
                engine.unpauseSendingMedia(kind);
                assert.isTrue(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
                assert.isTrue(engine.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
                return new Promise((resolve) => setTimeout(resolve, 500));
              })
              .then(() => assert.notCalled(spy));
          });
        });

        describe(`#(un)pauseReceivingMedia(${kind})`, () => {
          it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
            const engine = new WebRTCMediaEngine();
            engine.setMedia(`audio`, `sendrecv`);
            engine.setMedia(`video`, `sendrecv`);
            const spy = sinon.spy();

            return engine.createOffer()
              .then(mockAnswer)
              .then((answer) => Promise.all([
                expectEvent(20000, `track`, engine),
                engine.acceptAnswer(answer)
              ]))
              .then(() => {
                assertLocalMedia(engine, `sendrecv`, `sendrecv`);
                assertRemoteMedia(engine, `sendrecv`, `sendrecv`);

                engine.on(`negotiationneeded`, spy);
                engine.pauseReceivingMedia(kind);
                assert.isFalse(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
                assert.isFalse(engine.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
                return new Promise((resolve) => setTimeout(resolve, 500));
              })
              .then(() => assert.notCalled(spy))
              .then(() => {
                assertLocalMedia(engine, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);
                assertRemoteMedia(engine, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);

                engine.on(`negotiationneeded`, spy);
                engine.unpauseReceivingMedia(kind);
                assert.isTrue(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
                assert.isTrue(engine.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
                return new Promise((resolve) => setTimeout(resolve, 500));
              })
              .then(() => assert.notCalled(spy));
          });
        });

      });

    describe(`custom track`, () => {
      let engine;
      beforeEach(() => {
        engine = new WebRTCMediaEngine();
      });

      afterEach(() => {
        engine.stop();
      });


      it(`adds a track without internally calling getusermedia`, () => {
        let track;
        const spy = sinon.spy(engine, `_getUserMedia`);

        return WebRTCMediaEngine.getUserMedia({
          audio: true,
          video: false
        })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            engine.setMedia(`audio`, `sendrecv`, track);

            assert.lengthOf(engine.localMediaStream.getTracks(), 1);
            assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

            return engine.createOffer();
          })
          .then(mockAnswer)
          .then((answer) => Promise.all([
            expectEvent(20000, `track`, engine),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
            assert.notCalled(spy);
            assertLocalMedia(engine, `sendrecv`, `inactive`);
          });
      });

      it(`adds an external track without clobbering it`, () => {
        let track;

        return WebRTCMediaEngine.getUserMedia({
          audio: true,
          video: false
        })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            engine.setMedia(`audio`, `sendrecv`, track);
            engine.setMedia(`video`, `sendrecv`);

            assert.lengthOf(engine.localMediaStream.getTracks(), 1);
            assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

            return engine.createOffer();
          })
          .then(mockAnswer)
          .then((answer) => Promise.all([
            expectEvent(20000, `track`, engine),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`adds a new track to an inprogress connection`, () => {
        let track;

        engine.setMedia(`audio`, `inactive`);
        engine.setMedia(`video`, `sendrecv`);

        assert.lengthOf(engine.localMediaStream.getTracks(), 0);
        assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

        return engine.createOffer()
          .then(mockAnswer)
          .then((answer) => Promise.all([
            expectEvent(20000, `track`, engine),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assertLocalMedia(engine, `inactive`, `sendrecv`);
            return WebRTCMediaEngine.getUserMedia({
              audio: true,
              video: false
            });
          })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            assert.isDefined(track);
            engine.setMedia(`audio`, `sendrecv`, track);
            return expectEvent(20000, `negotiationneeded`, engine);
          })
          .then(() => engine.createOffer())
          .then(mockRenegotiate)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
          });
      });
    });

    describe(`custom constraints`, () => {
      let engine, spy;
      beforeEach(() => {
        engine = new WebRTCMediaEngine();
        spy = sinon.spy(WebRTCMediaEngine, `getUserMedia`);
      });

      afterEach(() => {
        engine.stop();
        spy.restore();
      });


      it(`starts a connection with custom constraints`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        engine.setMedia(`video`, `sendrecv`, {
          facingMode: {
            ideal: `user`
          }
        });

        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);
            assert.calledWith(spy, {
              audio: true,
              video: {
                facingMode: {
                  ideal: `user`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`replaces a track with with new contraints`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        engine.setMedia(`video`, `sendrecv`, {
          facingMode: {
            ideal: `user`
          }
        });

        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);
            assert.calledWith(spy, {
              audio: true,
              video: {
                facingMode: {
                  ideal: `user`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
            engine.setMedia(`video`, `sendrecv`, {
              facingMode: {
                ideal: `environment`
              }
            });

            return expectEvent(20000, `negotiationneeded`, engine);
          })
          .then(() => engine.createOffer())
          .then(mockAnswer)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledWith(spy, {
              video: {
                facingMode: {
                  ideal: `environment`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`adds a new track to an inprogress connection`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);

            assertLocalMedia(engine, `sendrecv`, `inactive`);
            engine.setMedia(`video`, `sendrecv`, {
              facingMode: {
                ideal: `environment`
              }
            });

            return expectEvent(20000, `negotiationneeded`, engine);
          })
          .then(() => engine.createOffer())
          .then(mockAnswer)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledWith(spy, {
              video: {
                facingMode: {
                  ideal: `environment`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });
    });
  });
});

function assertLocalKind(kind, direction, engine) {
  const tracks = engine.localMediaStream.getTracks().filter((t) => t.kind === kind);
  const senders = engine.pc.getSenders().filter((s) => s.track.kind === kind);
  if (direction.includes(`send`)) {
    assert.lengthOf(tracks, 1, `there is 1 local ${kind} track`);
    assert.lengthOf(senders, 1, `local ${kind} is ${direction}`);
    assert.isTrue(tracks[0].enabled, `the local ${kind} track is enabled`);
    assert.isTrue(senders[0].track.enabled, `local ${kind}is ${direction}`);
  }
  else {
    try {
      assert.lengthOf(tracks, 0, `there are 0 local ${kind} tracks`);
      assert.lengthOf(senders, 0, `there are 0 ${kind} senders`);
    }
    catch (err) {
      assert.lengthOf(tracks, 1, `there is 1 local ${kind} track`);
      assert.lengthOf(senders, 1, `local ${kind} is ${direction}`);
      assert.isFalse(tracks[0].enabled, `the local ${kind} track is not enabled`);
      assert.isFalse(senders[0].track.enabled, `local ${kind}is ${direction}`);
    }
  }
}

function assertRemoteKind(kind, direction, engine) {
  const tracks = engine.remoteMediaStream.getTracks().filter((t) => t.kind === kind);
  // const pcTracks = engine.pc.getRemoteStreams[0] && engine.pc.getRemoteStreams[0].getTracks().filter((t) => t.kind === kind);
  const receivers = engine.pc.getReceivers().filter((r) => r.track.kind === kind);

  if (direction.includes(`recv`)) {
    assert.lengthOf(tracks, 1, `there is 1 remote ${kind} track`);
    assert.isTrue(tracks[0].enabled, `the remote ${kind} track is enabled`);

    // assert.isDefined(pcTracks, `the peer connection has remote tracks`);
    // assert.lengthOf(pcTracks, 1, `there is 1 remote ${kind} track`);
    // assert.isTrue(pcTracks[0].enabled, `the remote ${kind} track is enabled`);


    // try {
    //   assert.lengthOf(receivers, 1, `there is 1 ${kind} receiver`);
    //   assert.isTrue(receivers[0].track.enabled, `the remote ${kind} receiver's track is enabled`);
    // }
    // catch (err) {
    //   assert.lengthOf(engine.pc.getRemoteStreams(), 1, `There is a remote stream`);
    //   assert.lengthOf(engine.pc.getRemoteStreams()[0].getTracks().filter((t) => t.kind === kind), 1, `There is 1 ${kind} track in the remote stream`);
    //   assert.isTrue(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled, `The is ${kind} track in the remote stream is enabled`);
    // }
  }
  else {
    try {
      assert.lengthOf(tracks, 0, `there are 0 remote ${kind} tracks`);
    }
    catch (err) {
      assert.lengthOf(tracks, 1, `there is 1 remote ${kind} track`);
      assert.isFalse(tracks[0].enabled, `the remote ${kind} track is not enabled`);
    }

    try {
      assert.lengthOf(receivers, 0, `there are 0 ${kind} receivers`);
    }
    catch (err) {
      assert.lengthOf(receivers, 1, `there is 1 ${kind} receivers`);
      assert.isFalse(receivers[0].track.enabled, `the remote ${kind} receiver's track is not enabled`);
    }
  }
}

function assertLocalMedia(engine, targetAudioDirection, targetVideoDirection) {
  assertLocalKind(`audio`, targetAudioDirection, engine);
  assertLocalKind(`video`, targetVideoDirection, engine);
}

function assertRemoteMedia(engine, targetAudioDirection, targetVideoDirection) {
  assertRemoteKind(`audio`, targetAudioDirection, engine);
  assertRemoteKind(`video`, targetVideoDirection, engine);
}

function assertOffer(kind, currentDirection, previousDirection, offer) {
  const sdpDirection = getMediaDirectionFromSDP(kind, offer);
  console.log(`offer ${kind}: ${sdpDirection}`);

  const fallbackDirection = getExpectedMediaDirection(currentDirection, previousDirection);

  // Don't wire up the fallback assertion if it wouldn't do any good (this helps
  // with line numbers)
  if (fallbackDirection === currentDirection) {
    assert.equal(sdpDirection, currentDirection, `expected "${kind}" offer to include "${currentDirection}"`);
    return;
  }

  try {
    assert.equal(sdpDirection, currentDirection, `expected "${kind}" offer to include "${currentDirection}"`);
  }
  catch (err) {
    assert.equal(sdpDirection, fallbackDirection, `expected "${kind}" offer to include "${currentDirection}" or "${fallbackDirection}"`);
  }
}

function assertAnswer(kind, currentDirection, previousDirection, answer) {
  const sdpDirection = getMediaDirectionFromSDP(kind, answer);
  console.log(`answer ${kind}: ${sdpDirection}`);
  const currentAnswerDirection = reverseMediaDirection(currentDirection);
  const fallbackDirection = reverseMediaDirection(getExpectedMediaDirection(currentDirection, previousDirection));

  // Don't wire up the fallback assertion if it wouldn't do any good (this helps
  // with line numbers)
  if (currentAnswerDirection === fallbackDirection) {
    assert.equal(sdpDirection, currentAnswerDirection, `expected "${kind}" answer to include "${currentAnswerDirection}"`);
    return;
  }

  try {
    assert.equal(sdpDirection, currentAnswerDirection, `expected "${kind}" answer to include "${currentAnswerDirection}"`);
  }
  catch (err) {
    assert.equal(sdpDirection, fallbackDirection, `expected "${kind}" answer to include "${currentAnswerDirection}" or "${fallbackDirection}"`);
  }
}

function assertSpyCalledOrNot(expectCall, spy) {
  if (expectCall) {
    assert.called(spy);
  }
  else {
    assert.notCalled(spy);
  }
}
