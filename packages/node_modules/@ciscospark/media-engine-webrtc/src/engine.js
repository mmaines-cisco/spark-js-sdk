import 'webrtc-adapter';
import {debounce} from 'lodash-decorators';
import {nonenumerable} from 'core-decorators';
import {make as makeTemplateContainer, oneFlight, tap, whileInFlight} from '@ciscospark/common';
import evented from '@ciscospark/common-evented';
import Events from 'ampersand-events';
import {defaults} from 'lodash';
import {
  ensureH264,
  limitBandwith,
  getMediaDirectionFromTracks,
  kindToPropertyFragment
} from './webrtc-helpers';

const DirectionContainer = makeTemplateContainer(WeakMap, Map);
const targetMediaDirection = new DirectionContainer();

/**
 * Wrapper around targetMediaDirection.get which returne `inactive` instead of
 * undefined
 * @param {string} target
 * @param {string} kind
 * @private
 * @returns {string}
 */
function getTargetMediaDirection(target, kind) {
  return targetMediaDirection.get(target, kind) || `inactive`;
}

/**
 * Interface for doing webrtc things
 * @protected
 */
export default class WebRTCMediaEngine {
  logger = console

  /**
   * Represents the local party's outgoing stream. Instantiated when the class
   * is instantiated.
   * @type {MediaStream}
   */
  localMediaStream = new MediaStream();

  /**
   * Represent the remote party's incoming media. Instantiated when the class is
   * instantiated.
   * @type {MediaStream}
   */
  remoteMediaStream = new MediaStream();

  /**
   * Reserved for future use
   * @type {MediaStream}
   */
  localSlideShare = new MediaStream()

  /**
   * Peer Connection
   * @type {RTCPeerConnection}
   */
  pc = new RTCPeerConnection({iceServers: []});

  @evented
  offerSdp = ``;

  @evented
  answerSdp = ``;

  /**
   * Returns the current audio direction
   * @returns {string}
   */
  get audioDirection() {
    return getMediaDirectionFromTracks(`audio`, this.pc);
  }

  /**
   * Returns the current video direction
   * @returns {string}
   */
  get videoDirection() {
    return getMediaDirectionFromTracks(`video`, this.pc);
  }

  /**
   * Constructor
   * @param {Object} attrs
   * @param {Logger} attrs.logger (optional): defaults to console
   * @returns {WebRTCMediaEngine}
   */
  constructor(attrs = {}) {
    if (attrs.logger) {
      this.logger = attrs.logger;
    }

    this.pc.onnegotiationneeded = () => {
      if (this.answerSdp) {
        this.triggerNegotiationNeeded();
      }
    };

    // Note: adapter.js doesn't seem to fully shim the track event.
    // addEventListener doesn't appear to work for it in chrome
    this.pc.ontrack = (event) => {
      this.trigger(`track`);
      event.streams[0]
        .getTracks()
        .forEach((track) => {
          this.remoteMediaStream.addTrack(track);
          track.onended = () => {
            this.remoteMediaStream.removeTrack(track);
            track.onended = undefined;
          };
        });
    };
  }

  /**
   * Creates an offer SDP
   * @returns {Promise<string>}
   */
  createOffer() {
    this.logger.info(`beginning negotiation`);
    let icePromise;

    if (!this.answerSdp) {
      icePromise = new Promise((resolve) => {
        this.logger.info(`configuring ice gathering`);
        this.pc.onicecandidate = (event) => {
          if (!event.candidate) {
            this.logger.info(`ice gathering complete`);
            resolve();
            return;
          }

          this.logger.info(`got ice candidate`);
        };
      });
    }

    return new Promise((resolve) => {
      if (this.gumming) {
        this.logger.info(`gum in flight, waiting until it completes`);
        this.once(`change:gumming`, resolve);
        return;
      }

      resolve();
    })
      .then(tap(() => this.logger.info(`creating offer`, this.offerOptions)))
      .then(() => this.pc.createOffer(this.offerOptions))
      .then(tap(() => this.logger.info(`setting local description`)))
      .then((offer) => this.pc.setLocalDescription(offer))
      .then(tap(() => this.logger.info(`blocking for ice gathering`)))
      .then(() => icePromise)
      .then(tap(() => this.logger.info(`limiting bandwith`)))
      .then(() => this.pc.localDescription.sdp)
      .then(limitBandwith)
      .then(tap(() => this.constraints.video && this.logger.info(`confirm h264 in offer`)))
      .then(ensureH264(this.constraints.video))
      .then(tap((sdp) => {
        this.offerSdp = sdp;
      }));
  }

  /**
   * Receives an answer SDP
   * @param {string} sdp
   * @returns {Promise}
   */
  acceptAnswer(sdp) {
    return this.pc.setRemoteDescription(new RTCSessionDescription({
      sdp,
      type: `answer`
    }))
      .then(() => {
        this.answerSdp = sdp;
      });
  }

  @nonenumerable
  /**
   * {@link MediaConstraints} that'll be used for the next call to {@link MediaDevices#getUserMedia()}
   * @private
   * @type {Object}
   */
  constraints = {};

  @nonenumerable
  /**
   * {@link RTCOfferOptions} that'll be used for the next call to
   * {@link RTCPeerConnection.createOffer}
   * @private
   * @type {Object}
   */
  offerOptions = {};

  @nonenumerable
  @evented
  /**
   * Indicates whether or not a call to {@link MediaDevices#getUserMedia()} is
   * in flight
   * @private
   * @type {boolean}
   */
  gumming = false

  // I don't see any way to make this less complex without just moving the
  // important bits of code further apart,
  /* eslint-disable complexity */
  /**
   * Sets a media direction for a given media type. Almost certainly triggers
   * renegotiation. This is the method to use if you want to replace a track.
   * @param {string} kind audio|video
   * @param {string} direction sendonly|recvonly|sendrecv|inactive
   * @returns {Promise}
   */
  setMedia(kind, direction) {
    if (direction === getTargetMediaDirection(this, kind)) {
      this.logger.info(`${kind} already transitioning to ${direction}, not making changes`);
      return;
    }

    targetMediaDirection.set(this, kind, direction);

    if (direction === this[`${kind}Direction`]) {
      this.logger.info(`${kind} already set to ${direction}, not making changes`);
      return;
    }

    this.logger.info(`transitioning ${kind} to ${direction}`);

    if (direction.includes(`send`)) {
      this.constraints[kind] = true;
      if (!this[`${kind}Direction`].includes(`send`)) {
        this._getUserMedia();
      }
    }
    else {
      this.constraints[kind] = false;
    }

    if (direction.includes(`recv`)) {
      this.offerOptions[`offerToReceive${kindToPropertyFragment(kind)}`] = true;
      if (this.remoteMediaStream.getTracks().find((t) => t.kind === kind)) {
        this.unpauseReceivingMedia(kind);
      }
      else if (this.answerSdp) {
        this.triggerNegotiationNeeded();
      }
    }
    else {
      this.offerOptions[`offerToReceive${kindToPropertyFragment(kind)}`] = false;
      if (this.remoteMediaStream.getTracks().find((t) => t.kind === kind)) {
        this.pauseReceivingMedia(kind);
      }
    }

    if (!this.constraints[kind]) {
      this.localMediaStream
        .getTracks()
        .filter((t) => t.kind === kind)
        .forEach((t) => {
          t.stop();
          this.localMediaStream.removeTrack(t);
          if (this.pc.removeTrack) {
            this.pc.removeTrack(this.pc.getSenders().find((s) => s.track === t));
          }
          else {
            this.pc.getLocalStreams()[0].removeTrack(t);
          }
        });
    }
  }
  /* eslint-enable complexity */

  @whileInFlight(`gumming`)
  @oneFlight
  /**
   * Wrapper around {@link MediaDevices#getUserMedia()} that delays to call one
   * tick to reduce the number of permissions dialogs presented to the user.   *
   * @returns {Promise<MediaStream>}
   */
  _getUserMedia() {
    return new Promise((resolve) => process.nextTick(resolve))
      .then(() => navigator.mediaDevices.getUserMedia(defaults({fake: process.env.NODE_ENV === `test`}, this.constraints)))
      .then((stream) => {
        stream.getTracks().forEach((t) => this.addOrReplaceTrack(t));
      });
  }

  /**
   * adds or replaces a local @{link MediaStreamTrack}
   * @private
   * @param {MediaStreamTrack} track
   * @returns {undefined}
   */
  addOrReplaceTrack(track) {
    this.logger.info(`preparing to add ${track.kind} to local media stream`);
    const existing = this.pc.getSenders().find((s) => s.track.kind === track.kind && s.track !== track);
    if (existing) {
      this.logger.info(`removing previous ${track.kind} from local media stream`);
      if (this.pc.removeTrack) {
        this.pc.removeTrack(existing);
      }
      this.localMediaStream.removeTrack(existing.track);
      // it may not be appropriate to stop the track if it was supplied by the
      // engine consumer, but I'm inclined not to deal with that unless it
      // becomes a real issue.
      track.stop();
    }

    this.logger.info(`adding ${track.kind} to local media stream`);
    this.localMediaStream.addTrack(track);
    this.logger.info(`adding ${track.kind} to peer connection`);
    this.pc.addTrack(track, this.localMediaStream);
  }

  /**
   * Stops sending useful bits on the identified track, but does not end it (the
   * camera/mic will stay on but the remote party(s) will not see/hear anything).
   * Avoids renegotiation. Throws if `kind` does not identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  pauseSendingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const senders = this.pc
      .getSenders()
      .filter((s) => s.track.kind === kind);

    if (senders.length === 0) {
      throw new Error(`No ${kind} media senders to pause`);
    }

    senders.forEach((s) => {
      this.logger.info(`pausing ${kind} sender`);
      s.track.enabled = false;
    });
  }

  /**
   * Resumes sending bits on the identified track. Throws if `kind` does not
   * identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  unpauseSendingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const senders = this.pc
      .getSenders()
      .filter((s) => s.track.kind === kind);

    if (senders.length === 0) {
      throw new Error(`No ${kind} media senders to unpause`);
    }

    senders.forEach((s) => {
      this.logger.info(`unpausing ${kind} sender`);
      s.track.enabled = true;
    });
  }

  /**
   * Convenience function. Sets a remote track.enabled=false. Does not
   * renegotiate.Throws if `kind` does not identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  pauseReceivingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const tracks = this.remoteMediaStream
      .getTracks()
      .filter((t) => t.kind === kind);

    if (tracks.length === 0) {
      throw new Error(`No remote ${kind} media tracks to pause`);
    }


    tracks.forEach((t) => {
      this.logger.info(`pausing remote ${kind} track`);
      t.enabled = false;
    });
  }

  /**
   * Convenience function. Sets a remote track.enabled=true. Does not
   * renegotiate.Throws if `kind` does not identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  unpauseReceivingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const tracks = this.remoteMediaStream
      .getTracks()
      .filter((t) => t.kind === kind);

    if (tracks.length === 0) {
      throw new Error(`No remote ${kind} media tracks to pause`);
    }

    tracks.forEach((t) => {
      this.logger.info(`unpausing remote ${kind} track`);
      t.enabled = true;
    });
  }

  /**
   * Stops all tracks and streams, closes the peer connection, and removes all
   * listeners
   * @returns {undefined}
   */
  stop() {
    if (this.pc.signalingState !== `closed`) {
      this.pc.getSenders().forEach((s) => s.track.stop());
      this.pc.close();
    }

    this.pc.onnegotiationneeded = undefined;
    this.pc.ontrack = undefined;
    this.pc.onicecandidate = undefined;
    this.off();
  }


  @debounce(500)
  /**
   * Debounced helper for triggering `negotiationneeded`. Only allows firing
   * after the first answer is recieved.
   * @private
   * @returns {undefined}
   */
  // It's not missing, but the decorator is throwing off eslint
  // eslint-disable-next-line require-jsdoc
  triggerNegotiationNeeded() {
    this.trigger(`negotiationneeded`);
  }
}

Object.assign(WebRTCMediaEngine.prototype, Events);
